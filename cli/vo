#!/usr/bin/env bash
#===============================================================================
# flocus - Focus & Flow for VS Code
#
# Opens files in the VS Code window that has the matching project open,
# determined by git repository root. Part of the flocus suite for managing
# developer focus and reducing cognitive overhead.
#
# Usage:
#   flocus open <file>        Open file in matching VS Code window
#   flocus open <file>:123    Open file at line 123
#   flocus open -z <file>     Open in zen mode (hide sidebar/panels)
#   flocus list               List open files in current project
#
# How it works:
#   1. Resolves file to absolute path
#   2. Detects git root of the file's directory
#   3. Reads registry (~/.config/flocus/registry.json) to find VS Code window
#      with matching workspace
#   4. Sends HTTP request to that window's flocus extension
#   5. Falls back to `code` command if no match or extension unreachable
#
# Dependencies: jq, curl, git, realpath (coreutils)
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------

REGISTRY_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flocus"
REGISTRY_FILE="$REGISTRY_DIR/registry.json"
CONFIG_FILE="$REGISTRY_DIR/config.json"
HEALTH_TIMEOUT=0.5  # seconds to wait for health check
REQUEST_TIMEOUT=2   # seconds to wait for open request

#-------------------------------------------------------------------------------
# Config Helpers
#-------------------------------------------------------------------------------

get_config_value() {
    local key="$1"
    local default="${2:-}"

    if [[ -f "$CONFIG_FILE" ]]; then
        local value
        value=$(jq -r --arg key "$key" '.[$key] // empty' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$value" ]]; then
            echo "$value"
            return
        fi
    fi
    echo "$default"
}

#-------------------------------------------------------------------------------
# Usage
#-------------------------------------------------------------------------------

usage() {
    cat <<EOF
Usage: flocus open [OPTIONS] <file>[:<line>]
       flocus open [OPTIONS] <directory>
       flocus list

Open a file or directory in the correct VS Code window.

Commands:
  open          Open a file or directory
  list          List all open files in the current project's VS Code window

Options (for 'open'):
  -z, --zen     Zen mode: hide Explorer sidebar and panels
  --raw         Use VS Code's default editor (bypass custom editor mappings)
  --all         Open all files in directory (NOT YET IMPLEMENTED)
  -h, --help    Show this help message
  --agent       Show context for AI agents

Examples:
  flocus open src/main.py          Open file in correct project window
  flocus open src/main.py:42       Open at line 42
  flocus open ~/projects/myapp     Open directory (registers for future calls)
  flocus open src/ --all           Open all files in src/ (NOT YET IMPLEMENTED)
  flocus open -z README.md         Open in zen mode
  flocus open --raw doc.md         Open markdown with default editor
  flocus list                      List all open files

Matching priority:
  1. Git repository root (if file is in a git repo)
  2. Parent workspace (if file is under an open VS Code folder)
  3. Orphan workspace (if configured in ~/.config/flocus/config.json)
  4. Falls back to 'code' command

Config (~/.config/flocus/config.json):
  {
    "orphanWorkspace": "/path/to/default/workspace"
  }
EOF
}

agent_context() {
    cat <<EOF
flocus - Context for AI Agents
==============================

flocus opens files in the *correct* VS Code window when multiple are open.

Key insight:
  - code ~/projects/myapp/src/main.py     →  opens in random/new window
  - flocus open ~/projects/myapp/src/main.py  →  opens in the window with myapp open

Setup: Open the project folder in VS Code first. This registers it.
Then flocus routes files there automatically. For one-off files outside
any project, the default orphan workspace works fine.

Match priority (automatic — just run 'flocus open <file>'):
  1. Git root         — file in a git repo → window with that repo open
  2. Parent workspace — file under any open VS Code folder
  3. Default orphan workspace — configured in ~/.config/flocus/config.json
  4. Fallback         — runs 'code' command (opens in last focused window)

Common patterns:
  flocus open <file>       Open in correct window
  flocus open <dir>        Open/focus folder (seeds registry for future calls)
  flocus list              List open tabs
  flocus open -z <file>    Zen mode (hide sidebar/panels)

Refer to 'flocus --help' for full option details.
EOF
}

#-------------------------------------------------------------------------------
# Logging (only in debug mode)
#-------------------------------------------------------------------------------

debug() {
    if [[ "${FLOCUS_DEBUG:-}" == "1" ]]; then
        echo "[flocus] $*" >&2
    fi
}

#-------------------------------------------------------------------------------
# Argument Parsing
#-------------------------------------------------------------------------------

ZEN=false
RAW=false
LIST=false
FILE=""
LINE=""

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -l|--list)
                LIST=true
                shift
                ;;
            -z|--zen)
                ZEN=true
                shift
                ;;
            --raw)
                RAW=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --agent)
                agent_context
                exit 0
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                usage >&2
                exit 1
                ;;
            *)
                # Parse file:line format
                # Handle edge case: Windows paths with colons (C:\...) - not relevant for our use
                # Handle edge case: File with colon in name - use last colon followed by digits only
                if [[ "$1" =~ ^(.+):([0-9]+)$ ]]; then
                    FILE="${BASH_REMATCH[1]}"
                    LINE="${BASH_REMATCH[2]}"
                else
                    FILE="$1"
                fi
                shift
                ;;
        esac
    done
}

#-------------------------------------------------------------------------------
# Core Logic
#-------------------------------------------------------------------------------

resolve_absolute_path() {
    local file="$1"

    # realpath resolves symlinks and makes path absolute
    # Use -m to not require file to exist (for creating new files)
    local resolved
    if ! resolved=$(realpath -m "$file" 2>/dev/null); then
        # Fallback for systems without -m flag
        resolved=$(realpath "$file" 2>/dev/null || echo "$file")
    fi

    # If file doesn't exist, try case-insensitive match
    if [[ ! -e "$resolved" ]]; then
        local dir basename match
        dir=$(dirname "$resolved")
        basename=$(basename "$resolved")

        if [[ -d "$dir" ]]; then
            # Find case-insensitive match in directory
            match=$(find "$dir" -maxdepth 1 -iname "$basename" -print -quit 2>/dev/null)
            if [[ -n "$match" ]]; then
                debug "Case-insensitive match: $basename -> $(basename "$match")"
                resolved="$match"
            fi
        fi
    fi

    echo "$resolved"
}

detect_git_root() {
    local file_dir="$1"

    # Get the directory containing the file
    if [[ -d "$file_dir" ]]; then
        local dir="$file_dir"
    else
        local dir
        dir=$(dirname "$file_dir")
    fi

    # Find git root
    git -C "$dir" rev-parse --show-toplevel 2>/dev/null || echo ""
}

find_matching_port() {
    local workspace="$1"

    if [[ ! -f "$REGISTRY_FILE" ]]; then
        debug "No registry file at $REGISTRY_FILE"
        echo ""
        return
    fi

    # Find window(s) matching workspace, pick most recently active
    local port
    port=$(jq -r --arg ws "$workspace" '
        .windows // []
        | map(select(.workspace == $ws))
        | sort_by(-.lastActive)
        | .[0].port // empty
    ' "$REGISTRY_FILE" 2>/dev/null || echo "")

    debug "Found port $port for workspace $workspace"
    echo "$port"
}

# Find a registered workspace that contains the given path
# Returns: "workspace:port" or empty string
find_parent_workspace() {
    local file_path="$1"

    if [[ ! -f "$REGISTRY_FILE" ]]; then
        echo ""
        return
    fi

    # Get all registered workspaces, sorted by path length (longest first)
    # This ensures we match the most specific workspace
    local result
    result=$(jq -r --arg path "$file_path" '
        .windows // []
        | map(. as $w | select($path | startswith($w.workspace + "/")))
        | sort_by(-(.workspace | length))
        | .[0] | if . then "\(.workspace):\(.port)" else empty end
    ' "$REGISTRY_FILE" 2>/dev/null || echo "")

    if [[ -n "$result" ]]; then
        debug "Found parent workspace: $result"
    fi
    echo "$result"
}

check_server_health() {
    local port="$1"

    curl -s --max-time "$HEALTH_TIMEOUT" "http://127.0.0.1:$port/health" >/dev/null 2>&1
}

send_open_request() {
    local port="$1"
    local file="$2"
    local line="$3"
    local zen="$4"
    local raw="$5"

    # Build JSON payload
    local payload
    if [[ -n "$line" ]]; then
        payload=$(jq -n \
            --arg file "$file" \
            --argjson line "$line" \
            --argjson zen "$zen" \
            --argjson raw "$raw" \
            '{file: $file, line: $line, zen: $zen, raw: $raw}')
    else
        payload=$(jq -n \
            --arg file "$file" \
            --argjson zen "$zen" \
            --argjson raw "$raw" \
            '{file: $file, zen: $zen, raw: $raw}')
    fi

    debug "Sending to port $port: $payload"

    curl -s --max-time "$REQUEST_TIMEOUT" \
        -X POST "http://127.0.0.1:$port/open" \
        -H "Content-Type: application/json" \
        -d "$payload"
}

send_files_request() {
    local port="$1"

    debug "Requesting file list from port $port"

    curl -s --max-time "$REQUEST_TIMEOUT" \
        -X GET "http://127.0.0.1:$port/files"
}

fallback_to_code() {
    local file="$1"
    local git_root="$2"

    debug "Falling back to code command"

    # Dry-run mode for testing - don't actually launch VS Code
    if [[ "${FLOCUS_DRY_RUN:-}" == "1" ]]; then
        if [[ -n "$git_root" ]]; then
            echo "[dry-run] code $git_root $file"
        else
            echo "[dry-run] code $file"
        fi
        return 0
    fi

    # Open with project context if we have git root
    if [[ -n "$git_root" ]]; then
        code "$git_root" "$file"
    else
        code "$file"
    fi
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

main() {
    parse_args "$@"

    # Handle list mode
    if [[ "$LIST" == "true" ]]; then
        list_files
        exit $?
    fi

    # Validate file argument
    if [[ -z "$FILE" ]]; then
        echo "Error: No file or directory specified" >&2
        echo "" >&2
        usage >&2
        exit 1
    fi

    # Step 1: Resolve to absolute path
    local abs_path
    abs_path=$(resolve_absolute_path "$FILE")
    debug "Resolved path: $abs_path"

    # Step 2: Handle directories
    if [[ -d "$abs_path" ]]; then
        open_directory "$abs_path"
        exit $?
    fi

    # Step 3: Open file
    open_file "$abs_path"
}

#-------------------------------------------------------------------------------
# Open Directory
#-------------------------------------------------------------------------------

open_directory() {
    local dir_path="$1"
    debug "Opening directory: $dir_path"

    # Check if this directory is already registered
    local port
    port=$(find_matching_port "$dir_path")

    if [[ -n "$port" ]] && check_server_health "$port"; then
        debug "Directory already open, focusing window"
        # Just focus the window - no file to open
        if [[ "${FLOCUS_DRY_RUN:-}" == "1" ]]; then
            echo "[dry-run] code $dir_path"
        else
            code "$dir_path"
            echo "Focused: $(basename "$dir_path")"
        fi
    else
        # Open the directory in a new VS Code window
        if [[ "${FLOCUS_DRY_RUN:-}" == "1" ]]; then
            echo "[dry-run] code $dir_path"
        else
            code "$dir_path"
            echo "Opened: $(basename "$dir_path")"
        fi
    fi
}

#-------------------------------------------------------------------------------
# Open File
#-------------------------------------------------------------------------------

open_file() {
    local abs_path="$1"

    # Step 1: Try git root matching
    local git_root
    git_root=$(detect_git_root "$abs_path")
    debug "Git root: ${git_root:-<none>}"

    local port=""
    local workspace=""

    if [[ -n "$git_root" ]]; then
        port=$(find_matching_port "$git_root")
        workspace="$git_root"
    fi

    # Step 2: Try path-based fallback (file under any registered workspace)
    if [[ -z "$port" ]]; then
        local parent_result
        parent_result=$(find_parent_workspace "$abs_path")
        if [[ -n "$parent_result" ]]; then
            workspace="${parent_result%%:*}"
            port="${parent_result##*:}"
            debug "Using parent workspace: $workspace on port $port"
        fi
    fi

    # Step 3: Try orphan workspace from config
    if [[ -z "$port" ]]; then
        local orphan_workspace
        orphan_workspace=$(get_config_value "orphanWorkspace")
        if [[ -n "$orphan_workspace" ]]; then
            port=$(find_matching_port "$orphan_workspace")
            if [[ -n "$port" ]]; then
                workspace="$orphan_workspace"
                debug "Using orphan workspace: $workspace on port $port"
            fi
        fi
    fi

    # Step 4: Try to send request to extension
    if [[ -n "$port" ]]; then
        if check_server_health "$port"; then
            debug "Server healthy on port $port"
            local response
            response=$(send_open_request "$port" "$abs_path" "$LINE" "$ZEN" "$RAW")
            if [[ $? -eq 0 ]]; then
                local success
                success=$(echo "$response" | jq -r '.success // false')
                if [[ "$success" == "true" ]]; then
                    local filename
                    filename=$(basename "$abs_path")
                    echo "Opened: $filename"

                    # Bring VS Code window to foreground
                    # Skip for temp directories (test environment) or if FLOCUS_NO_FOCUS is set
                    if [[ -z "${FLOCUS_NO_FOCUS:-}" && "$workspace" != /tmp/* ]]; then
                        code "$workspace" >/dev/null 2>&1 &
                    fi
                    exit 0
                else
                    local error
                    error=$(echo "$response" | jq -r '.error // "Unknown error"')
                    echo "Error: $error" >&2
                    exit 1
                fi
            fi
            debug "Request failed"
        else
            debug "Server not responding on port $port"
        fi
    fi

    # Step 5: Fallback to code command
    fallback_to_code "$abs_path" "$git_root"
}

#-------------------------------------------------------------------------------
# List Files Mode
#-------------------------------------------------------------------------------

list_files() {
    local cwd
    cwd=$(pwd)
    local port=""

    # Try git root first
    local git_root
    git_root=$(detect_git_root "$cwd")
    debug "Git root: ${git_root:-<none>}"

    if [[ -n "$git_root" ]]; then
        port=$(find_matching_port "$git_root")
    fi

    # Try path-based fallback
    if [[ -z "$port" ]]; then
        local parent_result
        parent_result=$(find_parent_workspace "$cwd")
        if [[ -n "$parent_result" ]]; then
            port="${parent_result##*:}"
            debug "Using parent workspace port: $port"
        fi
    fi

    # Try orphan workspace
    if [[ -z "$port" ]]; then
        local orphan_workspace
        orphan_workspace=$(get_config_value "orphanWorkspace")
        if [[ -n "$orphan_workspace" ]]; then
            port=$(find_matching_port "$orphan_workspace")
            debug "Using orphan workspace port: $port"
        fi
    fi

    if [[ -z "$port" ]]; then
        echo "Error: No VS Code window found for this location" >&2
        exit 1
    fi

    if ! check_server_health "$port"; then
        echo "Error: VS Code extension not responding" >&2
        exit 1
    fi

    debug "Server healthy on port $port"

    local response
    response=$(send_files_request "$port")

    local success
    success=$(echo "$response" | jq -r '.success // false')

    if [[ "$success" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "Unknown error"')
        echo "Error: $error" >&2
        exit 1
    fi

    # Print each file path on its own line
    echo "$response" | jq -r '.files[]'
}

main "$@"
